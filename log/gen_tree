#!/usr/bin/python
# -*- coding: utf-8 -*-

from xml.dom.minidom import *
import sys

filename = sys.argv[1]
dom = parse(filename)
root = dom.firstChild

primitives = ['bool', 'float', 'double']

typeMap = {'string': 'std::string'}

# Add int* and uint* to primitives and typeMap
for i in ['8', '16', '32', '64']:
    typename = 'int' + i
    typeMap[typename] = typename + '_t'
    typeMap['u' + typename] = 'u' + typename + '_t'
    primitives.append(typename)
    primitives.append('u' + typename)
	
class Enum:
	def __init__(self):
		self.ctype = None
		
		self.typename = None
		
		self.extType = None
		
		self.parent = None
		
	def type(self):
		if self.extType:
			return self.extType
		elif self.parent:
			return self.parent.type() + "::" + self.typename
			
		return "Packet::" + self.typename
	
class Struct:
	def __init__(self):
		self.members = {}
		
		self.typename = ""
		
		self.extType = None
		
		self.structs = []
	
		self.parent = None
		
		self.enums = []
		
		self.externOnly = True
		
	def type(self):
		if self.extType:
			return self.extType
		elif self.parent:
			return self.parent.type() + "::" + self.typename
		
		return "Packet::" + self.typename

def procStruct(root, parent = None):
	self = Struct()
	
	self.typename = root.getAttribute("typename")
	self.extType = root.getAttribute("external_cpp")
	self.parent = parent
	
	for node in root.childNodes:
		if node.nodeName == "struct":
			self.structs.append(procStruct(node, self))
		elif node.nodeName == "member":
			name = node.getAttribute("name")
			type = node.getAttribute("type")
			
			self.externOnly = False
			self.members[name] = type
		elif node.nodeName == "array":
			name = node.getAttribute("name")
			type = node.getAttribute("type")
			size = node.getAttribute("size")
			self.externOnly = False
			
			if not size:
				self.members[name] = type
			
		elif node.nodeName == "enum":
			enum = Enum()
			enum.typename = node.getAttribute("typename")
			enum.extType = node.getAttribute("external_cpp")
			enum.ctype = node.getAttribute("type")
			enum.parent = self
			
			self.enums.append(enum)
			
	return self
			
rootStruct = procStruct(root)

indentLevel = 0

def indent():
	global indentLevel
	indentLevel += 1
	
def unindent():
	global indentLevel
	indentLevel -= 1
	
def write(str = ''):
	if "}" in str:
		unindent()
		
	print ' ' * (indentLevel * 4) + str
	
	if "{" in str:
		indent()

def makeStruct(struct):
	if struct.externOnly:
		return
	
	for e in struct.enums:
		write("static void handleExt(QStandardItem* item, const %s& p)" % e.type())
		write("{")
		write("""item->setText(QString("%s: %%1").arg((%s_t)p));""" % (e.typename, e.ctype))
		write("}\n")

	for s in struct.structs:
		makeStruct(s)
		
	write("static void handleExt(QStandardItem* item, const %s& p)" % struct.type())
	write("{")
	
	write("for (int i=item->rowCount() ; i<%d ; ++i)" % len(struct.members))
	write("{")
	write("item->appendRow(new QStandardItem());")
	write("}\n")

	c = 0
	for k in struct.members:
		member = struct.members[k]
		if member in primitives:
			write("""item->child(%d)->setText(QString("%s: %%1").arg(p.%s));""" % (c, k,k))
		else:
			write("""item->child(%d)->setText(QString("%s"));""" % (c, k))
			write("""Log::handleExt(item->child(%d), p.%s);""" % (c, k))
		
		c += 1

	write("}\n")

write("#ifndef TREE_GEN_%s_HPP" % rootStruct.typename);
write("#define TREE_GEN_%s_HPP" % rootStruct.typename);

write("#include <stdint.h>");
write("#include <vector>");

write("namespace Log");
write("{")

makeStruct(rootStruct)

write("#ifndef TREE_GEN_VEC_HPP");
write("#define TREE_GEN_VEC_HPP");

write("template <typename T>")
write("void handleExt(QStandardItem* item, const std::vector< T > arr)")
write("{")

write("for (unsigned int i=item->rowCount() ; i<arr.size() ; ++i)")
write("{")
write("item->appendRow(new QStandardItem());")
write("}\n")

write("int i=0;")
write("Q_FOREACH(const T& a, arr)")
write("{")
write("handleExt(item->child(i), a);")
write("}\n")

write("}")

write("#endif //TREE_GEN_VEC_HPP\n");

write("}")

write("#endif //TREE_GEN_HPP");

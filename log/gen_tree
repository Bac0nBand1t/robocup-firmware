#!/usr/bin/python
# -*- coding: utf-8 -*-

from xml.dom.minidom import *
import sys

filename = sys.argv[1]
dom = parse(filename)
root = dom.firstChild

primitives = ['bool', 'float', 'double']

typeMap = {'string': 'std::string'}

# Add int* and uint* to primitives and typeMap
for i in ['8', '16', '32', '64']:
    typename = 'int' + i
    typeMap[typename] = typename + '_t'
    typeMap['u' + typename] = 'u' + typename + '_t'
    primitives.append(typename)
    primitives.append('u' + typename)
	
class Enum:
	def __init__(self):
		self.ctype = None
		
		self.typename = None
		
		self.extType = None
		
		self.parent = None
		
		self.items = {}
		
	def type(self):
		if self.extType:
			return self.extType
		elif self.parent:
			return self.parent.type() + "::" + self.typename
			
		return "Packet::" + self.typename
		
class Array:
	def __init__(self):
		self.name = None
		self.type = None
		self.size = None
	
class Struct:
	def __init__(self):
		self.members = {}
		
		self.typename = ""
		
		self.extType = None
		
		self.structs = []
	
		self.parent = None
		
		self.enums = []
		
		self.externOnly = True
		
		self.arrays = []
		
	def type(self):
		if self.extType:
			return self.extType
		elif self.parent:
			return self.parent.type() + "::" + self.typename
		
		return "Packet::" + self.typename

def procStruct(root, parent = None):
	self = Struct()
	
	self.typename = root.getAttribute("typename")
	self.extType = root.getAttribute("external_cpp")
	self.parent = parent
	
	for node in root.childNodes:
		if node.nodeName == "struct":
			self.structs.append(procStruct(node, self))
		elif node.nodeName == "member":
			name = node.getAttribute("name")
			type = node.getAttribute("type")
			
			self.externOnly = False
			self.members[name] = type
		elif node.nodeName == "array":
			a = Array()
			a.name = node.getAttribute("name")
			a.type = node.getAttribute("type")
			a.size = node.getAttribute("size")
			self.externOnly = False
			
			self.arrays.append(a)
			
		elif node.nodeName == "enum":
			enum = Enum()
			enum.typename = node.getAttribute("typename")
			enum.extType = node.getAttribute("external_cpp")
			enum.ctype = node.getAttribute("type")
			enum.parent = self
			
			i = 0
			for e in node.childNodes:
				n = node.getAttribute("name")
				v = node.getAttribute("value")
				
				if v:
					enum.items[v] = n
				else:
					enum.items[i] = n
					
				i += 1
			
			self.enums.append(enum)
			
	return self
			
rootStruct = procStruct(root)

indentLevel = 0

def indent():
	global indentLevel
	indentLevel += 1
	
def unindent():
	global indentLevel
	indentLevel -= 1
	
def write(str = ''):
	if "}" in str:
		unindent()
		
	print ' ' * (indentLevel * 4) + str
	
	if "{" in str:
		indent()

def makeStruct(struct):
	if struct.externOnly:
		return
	
	for e in struct.enums:
		write("static inline void handleExt(QStandardItem* item, const %s& p, const char* name=0)" % e.type())
		write("{")
		#write("""item->setText(QString("%s: %%1").arg((%s_t)p));""" % (e.typename, e.ctype))
		write("""QString s= "";""")
		write("switch (p)")
		write("{")
		for v in e.items:
			write("""case %s:""" % v)
			write("""\ts = "%s";""" % e.items[v])
			write("\tbreak;")
		write("}")
		write("""item->setText(s);""")
		write("}\n")

	for s in struct.structs:
		makeStruct(s)
		
	write("static inline void handleExt(QStandardItem* item, const %s& p, const char* name = 0)" % struct.type())
	write("{")
	
	write("if (name)")
	write("{")
	write("item->setText(name);")
	write("}else{")
	write("item->setText(\"%s\");" % struct.typename)
	write("}")
	
	write("for (int i=item->rowCount() ; i<%d ; ++i)" % (len(struct.members) + len(struct.arrays)))
	write("{")
	write("item->setChild(i,0, new QStandardItem());")
	write("item->setChild(i,1, new QStandardItem());")
	write("}\n")

	c = 0
	for k in struct.members:
		member = struct.members[k]
		write("""item->child(%d, 0)->setText("%s");""" % (c, k))
		if member in primitives:
			write("""Log::handleExt(item->child(%d, 1), p.%s);""" % (c, k))
			pass
		else:
			write("""Log::handleExt(item->child(%d, 0), p.%s, "%s");""" % (c, k, k))
			pass
		
		c += 1
		
	for a in struct.arrays:
		write("""item->child(%d, 0)->setText("%s");""" % (c, a.name))
		if a.size:
			write("""Log::handleExtArray(item->child(%d, 0), p.%s, %s);""" % (c, a.name, a.size))
			pass
		else:
			write("""Log::handleExtVector(item->child(%d, 0), p.%s);""" % (c, a.name))
			pass
			
		c += 1

	write("}\n")


write("#ifndef TREE_GEN_%s_HPP" % rootStruct.typename);
write("#define TREE_GEN_%s_HPP" % rootStruct.typename);

write("#include <TreeGen.hpp>");
write("#include <stdint.h>");
write("#include <vector>");
write("#include <string>");

write("namespace Log");
write("{")

makeStruct(rootStruct)

write("}")

write("#endif //TREE_GEN_HPP");

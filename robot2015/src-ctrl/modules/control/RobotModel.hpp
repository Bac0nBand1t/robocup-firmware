#pragma once

#define EIGEN_HAS_CXX11_MATH 0
#include <Eigen/Dense>
#include <array>
#include "Geometry2d/Util.hpp"
#undef M_PI  // TODO: this is garbage
#include "const-math.hpp"

/// Model parameters for a robot.  Used by the controls system.
class RobotModel {
public:
    /// Radius of omni-wheel (in meters)
    float WheelRadius;

    /// Distance from center of robot to center of wheel
    float WheelDist;

    /// Wheel angles (in radians) measured between +x axis and wheel axle
    std::array<float, 4> WheelAngles;

    /// V_bot = WheelToBot * wheelSpeeds;
    Eigen::Matrix<float, 3, 4> WheelToBot;

    /// wheelSpeeds = BotToWheel * V_bot
    /// BotToWheel = pseudoinverse(WheelToBot)
    Eigen::Matrix<float, 4, 3> BotToWheel;

    // NOTE: This chunk of code was previously used to generate the WheelToBot
    // matrix.  However, since BotToWheel can't be done in c++ (Eigen doesn't
    // support it), both matrices are now generated by Eigen.  See the comment
    // below.
    //
    // void regenerateDerivedMatrices() {
    //     const float pi2r = 2 * M_PI * WheelRadius;
    //     // clang-format off
    //     WheelToBot << -pi2r*sinf(WheelAngles[0]), -pi2r*sinf(WheelAngles[1]),
    //                      -pi2r*sinf(WheelAngles[2]),
    //                      -pi2r*sinf(WheelAngles[3]),
    //                   pi2r*cosf(WheelAngles[0]), pi2r*cosf(WheelAngles[1]),
    //                        pi2r*cosf(WheelAngles[2]),
    //                        pi2r*cosf(WheelAngles[3]),
    //                   WheelRadius/WheelDist/4, WheelRadius/WheelDist/4,
    //                            WheelRadius/WheelDist/4,
    //                            WheelRadius/WheelDist/4;
    //     // clang-format on
    // }

    /// (wheel rad/s desired) * DutyCycleMultiplier = duty cycle
    /// Note that this is an approximation, as the relationship isn't exactly
    /// linear
    float DutyCycleMultiplier;
};

/** Model parameters for 2015 robot
 *
 * NOTE: if any relevant parameters here are changed, the WheelToBot and
 * BotToWheel matrices must be re-generated manually.  The BotToWheel matrix is
 * the pseudo-inverse of WheelToBot and unfortunately Eigen doesn't have support
 * for this.  The workaround is to use matlab or octave (the open-source version
 * of matlab).  Run the RobotModel.m script to print out the values of the two
 * matrices and copy their contents below.
 */
static const RobotModel RobotModel2015 = []() {
    RobotModel model;
    model.WheelRadius = 0.02856;
    // note: wheels are numbered clockwise, starting with the top-right
    model.WheelAngles = {
        DegreesToRadians(38), DegreesToRadians(315), DegreesToRadians(225),
        DegreesToRadians(142),
    };
    model.WheelDist = 0.0798576;

    // @125 duty cycle, 1260rpm @ no load
    TODO(remeasure the duty cycle and rad / s relationship of the motor)
    model.DutyCycleMultiplier = 6;

    // Both of these matrices were calculated in Octave and pasted here

    // clang-format off
    model.WheelToBot <<
      -0.0107955,   0.0107955,   0.0107955,  -0.0107955,
       0.0100385,   0.0090079,  -0.0090079,  -0.0100385,
       0.0955902,   0.0832281,   0.0832281,   0.0955902;
    model.BotToWheel <<
      -21.5568,   27.5914,    2.7961,
       24.7586,   24.7586,    2.7961,
       24.7586,  -24.7586,    2.7961,
      -21.5568,  -27.5914,    2.7961;
    // clang-format on

    return model;
}();

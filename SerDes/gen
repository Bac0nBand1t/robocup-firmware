#!/usr/bin/python

# TODO:
#   Externals (for Point2d)

#   Strings
#   Support use of inner classes from any scope where they're available
#   Support code and real API
#   Enums: Correct type in C++, initialization
#   Initial values

import sys
from xml.dom.minidom import *

primitives = ['uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', 'uint64', 'int64', 'float', 'double']
enumTypes = {}

class Generator:
    # True if body should be called along with declarations.
    # This also prevents bodyHeader and bodyTrailer from being used.
    combined = False
    
    # Number of passes over the body
    bodyPasses = 1
    
    indentLevel = 0
    indentString = ''
    
    def indent(self):
        self.indentLevel += 1
        self.indentString += '    '
    def unindent(self):
        self.indentLevel -= 1
        self.indentString = self.indentString[:-4]
    
    def sizetype(self, node):
        s = node.getAttribute('sizetype')
        if s == '':
            return 'uint32'
        return s
        
    def write(self, str = ''):
        print self.indentString + str
    
    def declareBegin(self):
        pass
    def declareStructBegin(self, node):
        pass
    def declareConstant(self, node):
        pass
    def declareEnumBegin(self, node):
        pass
    def declareEnumItem(self, node, value):
        pass
    def declareEnumEnd(self, node):
        pass
    def declareMember(self, node):
        pass
    def declareArray(self, node):
        pass
    def declareStructEnd(self, node):
        pass
    def declareEnd(self):
        pass
    
    # npass is the number of the pass [0..bodyPasses)
    def bodyBegin(self, npass):
        pass
    def bodyStructBegin(self, npass, node):
        pass
    def bodyMember(self, npass, node):
        pass
    def bodyArray(self, npass, node):
        pass
    def bodyStructEnd(self, npass, node):
        pass
    def bodyEnd(self, npass):
        pass

class CppGenerator(Generator):
    # This writes out a single file, but is not combined because all the
    # bodies are at the end.
    
    headerGuard = '_TEST_HPP_'
    
    def properType(self, type):
        # Translate int8 to int8_t, etc.
        if type in primitives and (type[0:3] == 'int' or type[1:4] == 'int'):
            type += '_t'
        return type
    
    ########
    # Declarations
    
    def declareBegin(self):
        self.write('#ifndef ' + self.headerGuard)
        self.write('#define ' + self.headerGuard)
        self.write()
        self.write('#include <vector>')
        self.write('#include <Serialization.hpp>')
        self.write()
    
    def declareStructBegin(self, node):
        name = node.getAttribute('typename')
        self.write('class ' + name)
        self.write('{')
        self.indent()
        self.write('public:')
        self.write()
        self.primitiveMembers = []
    
    def declareConstant(self, node):
        type = node.getAttribute('type')
        cType = self.properType(type)
        name = node.getAttribute('name')
        value = node.getAttribute('value')
        self.write('static const ' + cType + ' ' + name + ' = ' + value + ';')
    
    def declareEnumBegin(self, node):
        self.write('typedef enum')
        self.write('{')
        self.indent()
    
    def declareEnumItem(self, node, value):
        name = node.getAttribute('name')
        #FIXME - It's correct but ugly to have a comma after the last item
        self.write(name + ' = ' + str(value) + ',')
    
    def declareEnumEnd(self, node):
        name = node.getAttribute('typename')
        self.unindent()
        self.write('} ' + name + ';')
        self.write()
    
    def declareMember(self, node):
        type = node.getAttribute('type')
        cType = self.properType(type)
        name = node.getAttribute('name')
        self.write(cType + ' ' + name + ';')
        
        if type in primitives:
            self.primitiveMembers.append(name)
    
    def declareArray(self, node):
        type = self.properType(node.getAttribute('type'))
        name = node.getAttribute('name')
        size = node.getAttribute('size')
        if size == '':
            # Variable size
            self.write('std::vector<' + type + '> ' + name + ';')
        else:
            # Fixed size
            self.write(type + ' ' + name + '[' + size + '];')
    
    def declareStructEnd(self, node):
        if self.primitiveMembers:
            # Default constructor
            name = node.getAttribute('typename')
            self.write()
            self.write(name + '()')
            self.write('{')
            self.indent()
            for name in self.primitiveMembers:
                self.write(name + ' = 0;')
            self.unindent()
            self.write('}')
        
        self.unindent()
        self.write('};')
        self.write()
    
    ########
    # Body
    
    def bodyStructBegin(self, npass, node):
        name = node.getAttribute('typename')
        parent = node.parentNode
        while parent != None and parent.nodeType == parent.ELEMENT_NODE:
            name = parent.getAttribute('typename') + '::' + name
            parent = parent.parentNode
        
        self.write('template<typename B>')
        self.write('void operator&(B &buf, ' + name + ' &obj)')
        self.write('{')
        self.indent()
    
    def bodyMember(self, npass, node):
        type = node.getAttribute('type')
        name = node.getAttribute('name')
        
        #FIXME - enums use wrong type
        if node.nodeName == 'array':
            # Array
            size = node.getAttribute('size')
            if size == '':
                # Variable size
                sizetype = self.properType(self.sizetype(node))
                self.write('buf.template arrayVariable<' + sizetype + '>(obj.' + name + ');')
            else:
                # Fixed size
                self.write('buf.arrayFixed(obj.' + name + ');')
        else:
            # Single object
            self.write('buf & obj.' + name + ';')
        
    def bodyStructEnd(self, npass, node):
        self.unindent()
        self.write('}')
        self.write()
    
    def bodyEnd(self, npass):
        self.write('#endif // ' + self.headerGuard)
    
class PythonGenerator(Generator):
    combined = True
    bodyPasses = 2
    
    # True if in the __init__ method
    init = False
    
    # Gets the type of a member, translating enums to
    # their underlying type.
    def realType(self, node):
        type = node.getAttribute('type')
        if type in enumTypes:
            type = enumTypes[type]
        return type
        
    def declareBegin(self):
        self.write('from Serialization import *')
        self.write()
        
    def declareStructBegin(self, node):
        name = node.getAttribute('typename')
        self.write('class ' + name + ':')
        self.indent()
    
    def declareConstant(self, node):
        name = node.getAttribute('name')
        value = node.getAttribute('value')
        self.write(name + ' = ' + value)
        
    def declareEnumItem(self, node, value):
        name = node.getAttribute('name')
        self.write(name + ' = ' + str(value))
    
    def declareMember(self, node):
        if not self.init:
            self.init = True
            self.write('def __init__(self):')
            self.indent()
        
        type = self.realType(node)
        
        name = node.getAttribute('name')
        value = node.getAttribute('value')
        if value == '':
            if type in primitives:
                value = '0'
            else:
                value = type + '()'
        self.write('self.' + name + ' = ' + value)
    
    def declareArray(self, node):
        if not self.init:
            self.init = True
            self.write('def __init__(self):')
            self.indent()
        
        name = node.getAttribute('name')
        size = node.getAttribute('size')
        if size == '':
            self.write(name + ' = []')
        else:
            type = self.realType(node)
            if type in primitives:
                self.write(name + ' = [0 for i in range(' + size + ')]')
            else:
                self.write(name + ' = [' + type + '() for i in range(' + size + ')]')
    
    def declareStructEnd(self, node):
        if self.init:
            self.unindent()
            self.init = False
        
        self.unindent()
        self.write()
    
    def bodyStructBegin(self, npass, node):
        if self.init:
            self.unindent()
            self.init = False
        
        self.write()
        if npass == 0:
            self.write('def read(self, buf):')
        else:
            self.write('def write(self, buf):')
        self.indent();
    
    def bodyMember(self, npass, node):
        type = self.realType(node)
        name = node.getAttribute('name')
        selfname = 'self.' + name
        
        if node.nodeName == 'member':
            if type in primitives:
                if npass == 0:
                    self.write(selfname + ' = buf.read_' + type + '()')
                else:
                    self.write('buf.write_' + type + '(' + selfname + ')')
            else:
                if npass == 0:
                    self.write(name + '.read(buf)')
                else:
                    self.write(name + '.write(buf)')
        elif node.nodeName == 'array':
            sizetype = self.sizetype(node)
            
            size = node.getAttribute('size')
            if size == '':
                if npass == 0:
                    self.write('self.' + name + ' = [None] * buf.read_' + sizetype + '()')
                else:
                    size = 'len(' + selfname + ')'
                    self.write('buf.write_' + sizetype + '(' + size + ');')
            
            if npass == 0:
                self.write('for i in range(len(' + selfname + ')):')
                self.indent()
                if type in primitives:
                    self.write(selfname + ' = buf.read_' + type + '()')
                else:
                    self.write(selfname + '[i].read(buf)')
            else:
                self.write('for i in ' + selfname + ':')
                self.indent()
                if type in primitives:
                    self.write('buf.write_' + type + '(i)')
                else:
                    self.write('i.write(buf)')
            self.unindent()
    
    def bodyStructEnd(self, npass, node):
        self.unindent()
    
########

def usage():
    print 'Usage: ' + sys.argv[0] + ' <-c|-p> <input.xml>'
    print '\t-c c++ output'
    print '\t-p python output'
    sys.exit(1)

gen = None
filename = None

for i in sys.argv[1:]:
    if i == '-c':
        gen = CppGenerator()
    elif i == '-p':
        gen = PythonGenerator()
    elif i.startswith('-'):
        print 'Unrecognized option ' + i
        usage()
    elif filename == None:
        filename = i
    else:
        print 'Extra filename ' + i
        usage()

if gen == None or filename == None:
    print 'Missing generator or filename'
    usage()

memberTags = ['member', 'array']

def structBody(npass, node):
    gen.bodyStructBegin(npass, node)
    for child in node.childNodes:
        if child.nodeType == node.ELEMENT_NODE and child.nodeName in memberTags:
            gen.bodyMember(npass, child)
    gen.bodyStructEnd(npass, node)

structs = []

def declareEnum(node):
    value = 0
    gen.declareEnumBegin(node)
    for child in node.getElementsByTagName('constant'):
        type = node.getAttribute('type')
        if type == '':
            type = 'uint32'
        enumTypes[node.getAttribute('typename')] = type
        
        valueAttr = child.getAttribute('value')
        if valueAttr != '':
            value = int(valueAttr)
        gen.declareEnumItem(child, value)
        value += 1
    gen.declareEnumEnd(node)

def declareNode(node):
    if node.nodeName == 'struct':
        name = node.getAttribute('typename')
        structs.append(node)
        gen.declareStructBegin(node)
        for child in node.childNodes:
            if child.nodeType == node.ELEMENT_NODE:
                declareNode(child)
        if gen.combined:
            for i in range(gen.bodyPasses):
                structBody(i, node)
        gen.declareStructEnd(node)
    elif node.nodeName == 'member':
        gen.declareMember(node)
    elif node.nodeName == 'array':
        gen.declareArray(node)
    elif node.nodeName == 'constant':
        gen.declareConstant(node)
    elif node.nodeName == 'enum':
        declareEnum(node)

dom = parse(filename)

# Declaration
gen.declareBegin()
declareNode(dom.getElementsByTagName('struct')[0])
gen.declareEnd()

# Body
for i in range(gen.bodyPasses):
    gen.bodyBegin(i)
    if not gen.combined:
        for node in structs:
            structBody(i, node)
    gen.bodyEnd(i)
